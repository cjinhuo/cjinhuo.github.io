<!DOCTYPE html><html lang="en"> <head><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://giscus.app"><link rel="dns-prefetch" href="https://lf1-cdn-tos.bytegoofy.com"><script>
  const initThemeFromLocalStorage = () => {
    const Dark = 'dark'
    const Light = 'light'
    const localStorageKey = '__shanks__theme'
    const addDarkToClassList = () => document.documentElement.classList.add(Dark)
    const removeDarkToClassList = () => document.documentElement.classList.remove(Dark)
    const theme = (() => {
      if (typeof localStorage !== 'undefined' && localStorage.getItem(localStorageKey)) {
        return localStorage.getItem(localStorageKey)
      }
      localStorage.setItem(localStorageKey, Dark)
      return Dark
    })()
    if (theme && theme === Dark) {
      addDarkToClassList()
    } else {
      removeDarkToClassList()
    }
  }
  initThemeFromLocalStorage()
  document.addEventListener('astro:after-swap', () => {
    initThemeFromLocalStorage()
  })
</script><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.17.1"><!-- Canonical URL --><link rel="canonical" href="https://cjinhuo.netlify.app/blogs/2019/vue26-reactive-analysis/"><!-- Primary Meta Tags --><title>Vue2.6响应式分析</title><meta name="title" content="Vue2.6响应式分析"><meta name="description" content="深入分析 Vue2.6 响应式原理，包括 defineReactive、Dep、Watcher 等核心概念"><meta name="author" content="Shanks"><meta name="keywords" content="源码解读, Vue, 前端"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://cjinhuo.netlify.app/blogs/2019/vue26-reactive-analysis/"><meta property="og:title" content="Vue2.6响应式分析"><meta property="og:description" content="深入分析 Vue2.6 响应式原理，包括 defineReactive、Dep、Watcher 等核心概念"><meta property="og:image" content="https://cjinhuo.netlify.app/placeholder-social.jpg"><meta property="og:site_name" content="Shanks"><meta property="article:author" content="Shanks"><meta property="article:published_time" content="2019-11-01"><meta property="article:tag" content="源码解读"><meta property="article:tag" content="Vue"><meta property="article:tag" content="前端"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://cjinhuo.netlify.app/blogs/2019/vue26-reactive-analysis/"><meta property="twitter:title" content="Vue2.6响应式分析"><meta property="twitter:description" content="深入分析 Vue2.6 响应式原理，包括 defineReactive、Dep、Watcher 等核心概念"><meta property="twitter:image" content="https://cjinhuo.netlify.app/placeholder-social.jpg"><meta property="twitter:creator" content="https://github.com/cjinhuo"><!-- Additional SEO --><meta name="robots" content="index, follow"><meta name="googlebot" content="index, follow"><!-- keywords --><meta data-react-helmet="true" name="keywords" content="前端监控,小程序监控,mitojs,cjinhuo,web monitoring,mini program monitoring,shanks,blogs,"><!-- description --><meta data-react-helmet="true" name="description" content="shank blog"><!-- sharecontent --><meta data-react-helmet="true" name="sharecontent" data-msg-img="./cjinhuo_blog.webp" data-msg-title="Shanks Blog" data-msg-content="前端监控,小程序监控,mitojs,cjinhuo,web monitoring,mini program monitoring,shanks,blogs"><!-- JSON-LD Structured Data --><script type="application/ld+json">
    {JSON.stringify({
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: title,
      description: description,
      image: socialImageURL.toString(),
      author: {
        '@type': 'Person',
        name: author,
        url: authorHref
      },
      publisher: {
        '@type': 'Organization',
        name: SITE_TITLE,
        logo: {
          '@type': 'ImageObject',
          url: new URL('/favicon.svg', Astro.url).toString()
        }
      },
      datePublished: pubDate,
      dateModified: updatedDate || pubDate,
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': canonicalURL.toString()
      }
    })}
  </script><link rel="stylesheet" href="/_astro/about.DpgBgVBT.css">
<link rel="stylesheet" href="/_astro/about.CArPWdo4.css"></head> <body class="bg-skin-background"> <header class="flex justify-between items-center"> <script async src="https://lf1-cdn-tos.bytegoofy.com/obj/iconpark/icons_19840_9.23068c8b37faf24c94259db4fbf93080.js">
  </script> <script type="module">const t=document.documentElement;function i(){const n=t.getBoundingClientRect().width/35;let e=16;n>16?e=16:n<12?e=12:e=n,t.style.fontSize=e+"px"}window.addEventListener("resize",i);window.addEventListener("DOMContentLoaded",i);</script> <a class="flex items-center gap-2.5 text-skin-neutral-1 hover:text-skin-neutral-3 font-semibold tracking-widest" href="/"> <span class="w-5 h-5 bg-skin-primary"></span> <span>SHANKS</span> </a> <div class="flex items-center gap-6"> <a target="_self" href="/blogs" title="Blog" aria-label="Blog" class="hover:text-skin-neutral-1 transition duration-75 text-base text-skin-neutral-5">Blog</a><a target="_blank" href="https://github.com/cjinhuo" title="Github" aria-label="Github" rel="noopener noreferrer" class="hover:text-skin-neutral-1 transition duration-75 text-base text-skin-neutral-5"><div style="width:20px;height:20px" class="hover:text-skin-neutral-1 text-skin-neutral-5"><iconpark-icon style="font-size:20px;vertical-align:middle;transition:color 0.02s" name="github"></iconpark-icon></div></a> <div class="w-5 h-5"> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="1mqAKG" component-url="/_astro/ToggleTheme.oJg5Xdcy.js" component-export="default" renderer-url="/_astro/client.Dc9Vh3na.js" props="{}" ssr client="only" opts="{&quot;name&quot;:&quot;ToggleTheme&quot;,&quot;value&quot;:&quot;react&quot;}"></astro-island> </div> </div> <meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.CDGfc0hd.js"></script> </header> <main class="min-h-screen">  <article class="max-w-4xl mx-auto px-6 md:px-12 py-12"> <h1 class="text-3xl md:text-4xl font-bold text-skin-neutral-1 tracking-tight mb-6">Vue2.6响应式分析</h1> <div class="flex flex-wrap items-center gap-x-8 gap-y-2 mb-6"> <div class="flex items-center gap-2"> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-skin-neutral-6"> <rect width="18" height="18" x="3" y="4" rx="2" ry="2"></rect> <line x1="16" x2="16" y1="2" y2="6"></line> <line x1="8" x2="8" y1="2" y2="6"></line> <line x1="3" x2="21" y1="10" y2="10"></line> </svg> <time class="text-skin-neutral-5 font-mono text-xs">2019-11-01</time> </div> <div class="flex items-center gap-2"> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-skin-neutral-6"> <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"></path> <circle cx="12" cy="7" r="4"></circle> </svg> <a href="https://github.com/cjinhuo" target="_blank" class="text-skin-neutral-5 font-mono text-xs hover:text-skin-primary hover:underline transition-colors"> Shanks </a> </div> <div class="flex items-center gap-2"> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-skin-neutral-6"> <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path> <polyline points="14 2 14 8 20 8"></polyline> </svg> <span class="text-skin-neutral-5 font-mono text-xs">4,644 字</span> </div> <div class="flex items-center gap-2"> <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-skin-neutral-6"> <circle cx="12" cy="12" r="10"></circle> <polyline points="12 6 12 12 16 14"></polyline> </svg> <span class="text-skin-neutral-5 font-mono text-xs">约 12 min</span> </div> </div> <div class="flex flex-wrap gap-2 mb-6"><span class="inline-flex items-center px-2 py-1 text-xs font-bold bg-skin-tag-bg text-skin-tag-text font-mono">源码解读</span><span class="inline-flex items-center px-2 py-1 text-xs font-bold bg-skin-tag-bg text-skin-tag-text font-mono">Vue</span><span class="inline-flex items-center px-2 py-1 text-xs font-bold bg-skin-tag-bg text-skin-tag-text font-mono">前端</span></div> <div class="h-px bg-skin-card-border mb-8"></div>  <div class="prose prose-slate dark:prose-invert max-w-none"> <div class="custom-container tip"><p class="custom-container-title">提示</p><ol>
<li>message为data中定义的对象，vm._data.message和vm.message有什么区别？</li>
<li>为什么Vue中不能通过索引来修改数组以更新视图？为什么有时候莫名其妙就可以触发视图更新？</li>
<li>为什么只能通过官网指定的几个方法(push、splice…)才能出发数组数据更新？</li>
<li>为什么通过this.$set就可以触发数组下标更新导致更新视图？</li>
<li>computed和watch的区别有哪些，computed的缓存是怎么做到的？</li>
<li>社区经常提到的watcher和dep到底为响应式数据提供了怎么样的逻辑？</li>
</ol></div>
<!-- more -->
<p>需要解答上面一系列问题，需要从Vue的_init开始走起。下面得是Vue2.6的源码照搬过来的，基本上每一行都会有注释，但是有一些通过命名就看出来的就没有注释了，可能源码较多，所以我画了流程图，推荐是拿着Vue提供的开发版源码<a href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">Vue开发版源码地址</a>，然后在new Vue()断点，慢慢的走一遍，然后再回来看这边文章，可能会解答更多的困惑。</p>
<h2 id="_init">_init</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>初始化函数，option就是你定义的data、methods、created等等Vue提供的一些属性。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#79B8FF">Vue</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_init</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> vm </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  // 做个标记，避免后面被Observer()实例化，因为组件不用观察，需要观察的是数据</span></span>
<span class="line"><span style="color:#E1E4E8">  vm._isVue </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  {</span></span>
<span class="line"><span style="color:#B392F0">    initProxy</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // expose real self</span></span>
<span class="line"><span style="color:#E1E4E8">  vm._self </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm;</span></span>
<span class="line"><span style="color:#B392F0">  initLifecycle</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#B392F0">  initEvents</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#B392F0">  initRender</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#6A737D">  // beforeCreate 函数调用</span></span>
<span class="line"><span style="color:#B392F0">  callHook</span><span style="color:#E1E4E8">(vm, </span><span style="color:#9ECBFF">'beforeCreate'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">  initInjections</span><span style="color:#E1E4E8">(vm); </span><span style="color:#6A737D">// resolve injections before data/props</span></span>
<span class="line"><span style="color:#B392F0">  initState</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#B392F0">  initProvide</span><span style="color:#E1E4E8">(vm); </span><span style="color:#6A737D">// resolve provide after data/props</span></span>
<span class="line"><span style="color:#6A737D">  // created 函数调用</span></span>
<span class="line"><span style="color:#B392F0">  callHook</span><span style="color:#E1E4E8">(vm, </span><span style="color:#9ECBFF">'created'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">  // 查询是否有节点，并挂载到当前节点</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (vm.$options.el) {</span></span>
<span class="line"><span style="color:#E1E4E8">    vm.</span><span style="color:#B392F0">$mount</span><span style="color:#E1E4E8">(vm.$options.el);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span></code></pre>
<p>先走<a style="color:rgb(122, 214, 253);" href="#initproxy">initProxy</a></p>
<h2 id="initproxy">initProxy</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>首先判断Proxy(<a style="color:rgb(122, 214, 253);" href="#proxy的traps">了解Proxy</a>)是否可用，如果可用就定义<code>has</code>或<code>get</code>traps放入Proxy，返回给vm._renderProxy。改方法只在开发环境下才会运行，主要是为了检查当前编写的Vue组件是否有错误，如果有就会在控制台报错。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="javascript"><code><span class="line"><span style="color:#F97583">    var</span><span style="color:#B392F0"> initProxy</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> initProxy</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">vm</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // hasProxy => typeof Proxy !== 'undefined' &#x26;&#x26; isNative(Proxy);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (hasProxy) {</span></span>
<span class="line"><span style="color:#6A737D">        // 决定使用哪个代理handler</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> options </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm.$options;</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> handlers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options.render </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> options.render._withStripped</span></span>
<span class="line"><span style="color:#F97583">          ?</span><span style="color:#E1E4E8"> getHandler</span></span>
<span class="line"><span style="color:#F97583">          :</span><span style="color:#E1E4E8"> hasHandler;</span></span>
<span class="line"><span style="color:#E1E4E8">        vm._renderProxy </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Proxy</span><span style="color:#E1E4E8">(vm, handlers);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        vm._renderProxy </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p>判断当前环境Proxy是否可用。如果可用就是执行:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#E1E4E8">vm._renderProxy </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Proxy</span><span style="color:#E1E4E8">(vm, handlers);</span></span></code></pre>
<p>然后看这个<code>handlers</code>是啥。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> handlers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options.render </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> options.render._withStripped</span></span>
<span class="line"><span style="color:#F97583">          ?</span><span style="color:#E1E4E8"> getHandler</span></span>
<span class="line"><span style="color:#F97583">          :</span><span style="color:#E1E4E8"> hasHandler;</span></span></code></pre>
<p>上面的<code>render._withStripped</code>搜了一下是内部标志，用来正确选择proxy，大部分情况都是undefined，所有<code>handles</code>基本都是<code>hasHandler</code></p>
<div class="custom-container tip"><p class="custom-container-title">render._withStripped github issues</p><p>This is an internal flag that allows Vue’s runtime to pick the correct Proxy strategy to detect variable reference errors during render, depending on whether with has been stripped by vue-template-es2015-compiler.</p></div>
<h2 id="gethandler--hashandler">getHandler &#x26;&#x26; hasHandler</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>这两种方法主要是为了当用户错误操作vm的属性提示报错。比如调用for in循环遍历vm实例属性时，会触发hasHandler方法，调用vm._data就会触发gethandler方法。</p></div>
<p>看上面两个对象前先看一个工具函数:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">    // allowedGlobals是一个映射表，映射下面列出的类型，</span></span>
<span class="line"><span style="color:#6A737D">    // allowedGlobals('Infinity') => true</span></span>
<span class="line"><span style="color:#6A737D">    // allowedGlobals('test') => false</span></span>
<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> allowedGlobals </span><span style="color:#F97583">=</span><span style="color:#B392F0"> makeMap</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">      'Infinity,undefined,NaN,isFinite,isNaN,'</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,'</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,'</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">      'require'</span><span style="color:#6A737D"> // for Webpack/Browserify</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#6A737D">    // 生成一个map对象和返回一个函数来检查是否含有某个键</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> makeMap</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#FFAB70">    str</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    expectsLowerCase</span></span>
<span class="line"><span style="color:#E1E4E8">  ) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> map </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> list </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> str.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">','</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> list.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      map[list[i]] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> expectsLowerCase</span></span>
<span class="line"><span style="color:#F97583">      ?</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> map[val.</span><span style="color:#B392F0">toLowerCase</span><span style="color:#E1E4E8">()]; }</span></span>
<span class="line"><span style="color:#F97583">      :</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> map[val]; }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">// 这个对象包含一个方法has，用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> hasHandler </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      has</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#B392F0"> has</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">target</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> has </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target;</span></span>
<span class="line"><span style="color:#6A737D">        // allowedGlobals('Infinity') => true</span></span>
<span class="line"><span style="color:#6A737D">        // 当访问的属性是一些js默认定义（allowedGlobals）的类型之一</span></span>
<span class="line"><span style="color:#6A737D">        // 或者不是string类型且key不是_开头的且属性不在target.$data上返回true</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> isAllowed </span><span style="color:#F97583">=</span><span style="color:#B392F0"> allowedGlobals</span><span style="color:#E1E4E8">(key) </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#E1E4E8">          (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'string'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8"> key.</span><span style="color:#B392F0">charAt</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> '_'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target.$data));</span></span>
<span class="line"><span style="color:#6A737D">          // 如果属性不在target上且没有通过isAllowed判断，就抛出错误提示</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">has </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">isAllowed) {</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target.$data) { </span><span style="color:#B392F0">warnReservedPrefix</span><span style="color:#E1E4E8">(target, key); }</span></span>
<span class="line"><span style="color:#F97583">          else</span><span style="color:#E1E4E8"> { </span><span style="color:#B392F0">warnNonPresent</span><span style="color:#E1E4E8">(target, key); }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> has </span><span style="color:#F97583">||</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">isAllowed</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#6A737D">// 针对读取代理对象的某个属性时进行的操作</span></span>
<span class="line"><span style="color:#6A737D">// 当访问的属性不是string类型或者属性值在被代理的对象不存在，则抛出错误提示，否则就返回该属性值</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> getHandler </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      get</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#B392F0"> get</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">target</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'string'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target)) {</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target.$data) { </span><span style="color:#B392F0">warnReservedPrefix</span><span style="color:#E1E4E8">(target, key); }</span></span>
<span class="line"><span style="color:#F97583">          else</span><span style="color:#E1E4E8"> { </span><span style="color:#B392F0">warnNonPresent</span><span style="color:#E1E4E8">(target, key); }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> target[key]</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span></code></pre>
<h2 id="proxy的traps">proxy的traps</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>proxy所有的traps是可选的。如果某个trap没有定义，那么默认的行为会应用到目标对象上</p></div>
<p>上面当两个handles处理好后，将要执行<code>vm._renderProxy = new Proxy(vm, handlers);</code>，getHandle对应的是get方法，hasHandler对应的是has方法。</p>
<ul>
<li>handler.has()<br>
在判断代理对象是否拥有某个属性时触发该操作，比如在执行 “foo” in proxy 时。</li>
<li>handler.get()<br>
在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</li>
</ul>
<h2 id="initproxy的流程">initProxy的流程</h2>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1024" height="768" src="/_astro/vue2-init-proxy.Df2h43ve_VJLoI.webp" ></p>
<h2 id="initstate">initState</h2>
<p>自己理解initState后面的一些流程，省略了其他的模块：
<img  loading="lazy" decoding="async" fetchpriority="auto" width="1097" height="987" src="/_astro/vue2-initState.z9WMfXrw_Z20IOtk.webp" ></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> initState</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">vm</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 定义vm的watchers，便于在new Watcher时收集已经实例化的watcher</span></span>
<span class="line"><span style="color:#E1E4E8">    vm._watchers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> opts </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm.$options;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (opts.props) { </span><span style="color:#B392F0">initProps</span><span style="color:#E1E4E8">(vm, opts.props); }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (opts.methods) { </span><span style="color:#B392F0">initMethods</span><span style="color:#E1E4E8">(vm, opts.methods); }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (opts.data) {</span></span>
<span class="line"><span style="color:#6A737D">    // 继续走initData</span></span>
<span class="line"><span style="color:#B392F0">      initData</span><span style="color:#E1E4E8">(vm);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      observe</span><span style="color:#E1E4E8">(vm._data </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {}, </span><span style="color:#79B8FF">true</span><span style="color:#6A737D"> /* asRootData */</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (opts.computed) { </span><span style="color:#B392F0">initComputed</span><span style="color:#E1E4E8">(vm, opts.computed); }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (opts.watch </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> opts.watch </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> nativeWatch) {</span></span>
<span class="line"><span style="color:#B392F0">      initWatch</span><span style="color:#E1E4E8">(vm, opts.watch);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h2 id="initdata">initData</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>初始化data对象，这里面包括定义响应式数据，重点是会新建vm._data属性里面，然后里面放入的是你预定的属性，再将_data的所有属性代理到vm上面，将<code>vm[key]</code>代理到<code>_data[key]</code>
下面的流程推荐在源码中断点走一遍，不理解的再回来看看注释。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> initData</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">vm</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> data </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm.$options.data;</span></span>
<span class="line"><span style="color:#6A737D">    // 不管是函数还是对象，最终返回的都是纯对象，如果不是纯对象就抛出warn，因为我们只需要data里面预定的属性</span></span>
<span class="line"><span style="color:#6A737D">    // 并且赋值给vm._data</span></span>
<span class="line"><span style="color:#E1E4E8">    data </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm._data </span><span style="color:#F97583">=</span><span style="color:#F97583"> typeof</span><span style="color:#E1E4E8"> data </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'function'</span></span>
<span class="line"><span style="color:#F97583">      ?</span><span style="color:#B392F0"> getData</span><span style="color:#E1E4E8">(data, vm) </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> data </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#6A737D">      // getData(data, vm) =>  return data.call(vm, vm)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">isPlainObject</span><span style="color:#E1E4E8">(data)) {</span></span>
<span class="line"><span style="color:#E1E4E8">      data </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#B392F0">      warn</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> keys </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">keys</span><span style="color:#E1E4E8">(data);</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> props </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm.$options.props;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> methods </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm.$options.methods;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> keys.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> keys[i];</span></span>
<span class="line"><span style="color:#E1E4E8">      {</span></span>
<span class="line"><span style="color:#6A737D">        // 判断data的key有没有在prop或methods已经定义过</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (methods </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> hasOwn</span><span style="color:#E1E4E8">(methods, key)) {</span></span>
<span class="line"><span style="color:#B392F0">          warn</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (props </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> hasOwn</span><span style="color:#E1E4E8">(props, key)) {</span></span>
<span class="line"><span style="color:#B392F0">        warn</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">isReserved</span><span style="color:#E1E4E8">(key)) { </span><span style="color:#6A737D">// isReserved判断字符串是否是$开头,</span></span>
<span class="line"><span style="color:#6A737D">        // 将vm[key]代理到_data[key]</span></span>
<span class="line"><span style="color:#6A737D">        // 取vm[key]的值就是取_data[key]的值</span></span>
<span class="line"><span style="color:#6A737D">        // vm.message  => vm._data.message</span></span>
<span class="line"><span style="color:#B392F0">        proxy</span><span style="color:#E1E4E8">(vm, </span><span style="color:#9ECBFF">"_data"</span><span style="color:#E1E4E8">, key);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // observe data 观察data</span></span>
<span class="line"><span style="color:#B392F0">    observe</span><span style="color:#E1E4E8">(data, </span><span style="color:#79B8FF">true</span><span style="color:#6A737D"> /* asRootData */</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p><code>proxy(vm, "_data", key);</code>这里的实现很巧妙，点击<a style="color:rgb(122, 214, 253);" href="#proxy">proxy函数</a>跳到函数实现。</p>
<p><code>observe(data, true /* asRootData */);</code>是观察data里面的所有属性，也是开始定义响应式数据的入口点了。点击<a style="color:rgb(122, 214, 253);" href="#observe（判断是否需要观察）">observer</a>函数实现</p>
<h2 id="initcomputed">initComputed</h2>
<div class="custom-container tip"><p class="custom-container-title">initComputed流程</p><pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#B392F0">computed</span><span style="color:#E1E4E8">:{</span></span>
<span class="line"><span style="color:#B392F0">  result</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.message </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> 'computed'</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre><p>假设computed是上面的数据，首先创建不带任何的原型链的空对象赋值到当前vm上<code>var watchers = vm._computedWatchers = Object.create(null);</code>，然后遍历computed，跟watch一样，computed也可以是多种写法，经过一系列判断，最终导出set（如果没有就为noop），get函数，然后实例化Watcher，和watch不同的是，是实例化Watcher的时候最后一个参数变成<code>{ lazy: true }</code>，这个是缓存的标志，在实例化watcher的过程中并不会执行到<code>watcher.get</code>，但是在后续会给当前计算属性<code>result</code>设置getter方法，在页面获取值时就会触发getter方法，判断<code>watcher.dirty</code>是否是true，如果是的话就执行<code>watcher.evaluate()</code>，在<code>evaluate()</code>中重新获取<code>watcher.get()</code>。可以知道计算属性是通过<code>watcher.dirty</code>来判断是否需要重新获取值，在<code>this.message</code>更改值时会触发notify，然后执行对应的<code>watcher.update</code>，在<code>update</code>中<code>watcher.dirty</code>变成true。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> initComputed</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">vm</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">computed</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 创建不带任何的原型链的空对象并且挂载到当前组件的实例上</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> watchers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm._computedWatchers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> isSSR </span><span style="color:#F97583">=</span><span style="color:#B392F0"> isServerRendering</span><span style="color:#E1E4E8">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> computed) {</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> userDef </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> computed[key];</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> getter </span><span style="color:#F97583">=</span><span style="color:#F97583"> typeof</span><span style="color:#E1E4E8"> userDef </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'function'</span><span style="color:#F97583"> ?</span><span style="color:#E1E4E8"> userDef </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> userDef.get;</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (getter </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">        warn</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">          (</span><span style="color:#9ECBFF">"Getter is missing for computed property </span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">."</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">          vm</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">isSSR) {</span></span>
<span class="line"><span style="color:#6A737D">        // 针对option.computed中的每个key进行Watcher</span></span>
<span class="line"><span style="color:#6A737D">        // watcher 用来存储计算值，判断是否需要重新计算</span></span>
<span class="line"><span style="color:#E1E4E8">        watchers[key] </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Watcher</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">          vm,</span></span>
<span class="line"><span style="color:#E1E4E8">          getter </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> noop, </span><span style="color:#6A737D">// 用watcher保存getter函数</span></span>
<span class="line"><span style="color:#E1E4E8">          noop,</span></span>
<span class="line"><span style="color:#E1E4E8">          computedWatcherOptions</span></span>
<span class="line"><span style="color:#6A737D">          // computedWatcherOptions = { lazy: true };作用是初始化watcher的第一次不执行this.get()，也就是不会获取当前值，只在用到的时候获取</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // 如果key不在vm属性在指定的对象或其原型链中，就执行defineComputed</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> vm)) {</span></span>
<span class="line"><span style="color:#B392F0">        defineComputed</span><span style="color:#E1E4E8">(vm, key, userDef);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> vm.$data) {</span></span>
<span class="line"><span style="color:#B392F0">          warn</span><span style="color:#E1E4E8">((</span><span style="color:#9ECBFF">"The computed property </span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF"> is already defined in data."</span><span style="color:#E1E4E8">), vm);</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (vm.$options.props </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> vm.$options.props) {</span></span>
<span class="line"><span style="color:#B392F0">          warn</span><span style="color:#E1E4E8">((</span><span style="color:#9ECBFF">"The computed property </span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF"> is already defined as a prop."</span><span style="color:#E1E4E8">), vm);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="definecomputed">defineComputed</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> defineComputed</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#FFAB70">    target</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    key</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    userDef</span></span>
<span class="line"><span style="color:#E1E4E8">  ) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> shouldCache </span><span style="color:#F97583">=</span><span style="color:#F97583"> !</span><span style="color:#B392F0">isServerRendering</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> userDef </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'function'</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      sharedPropertyDefinition.get </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> shouldCache</span></span>
<span class="line"><span style="color:#F97583">        ?</span><span style="color:#B392F0"> createComputedGetter</span><span style="color:#E1E4E8">(key)</span></span>
<span class="line"><span style="color:#F97583">        :</span><span style="color:#B392F0"> createGetterInvoker</span><span style="color:#E1E4E8">(userDef);</span></span>
<span class="line"><span style="color:#E1E4E8">      sharedPropertyDefinition.set </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> noop;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">      // 当计算属性是对象时，判断用户有没有设置set，有的话将用户的set赋值</span></span>
<span class="line"><span style="color:#E1E4E8">      sharedPropertyDefinition.get </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> userDef.get</span></span>
<span class="line"><span style="color:#F97583">        ?</span><span style="color:#E1E4E8"> shouldCache </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> userDef.cache </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> false</span></span>
<span class="line"><span style="color:#F97583">          ?</span><span style="color:#B392F0"> createComputedGetter</span><span style="color:#E1E4E8">(key)</span></span>
<span class="line"><span style="color:#F97583">          :</span><span style="color:#B392F0"> createGetterInvoker</span><span style="color:#E1E4E8">(userDef.get)</span></span>
<span class="line"><span style="color:#F97583">        :</span><span style="color:#E1E4E8"> noop;</span></span>
<span class="line"><span style="color:#E1E4E8">      sharedPropertyDefinition.set </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> userDef.set </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> noop;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (sharedPropertyDefinition.set </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> noop) {</span></span>
<span class="line"><span style="color:#E1E4E8">      sharedPropertyDefinition.</span><span style="color:#B392F0">set</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#B392F0">        warn</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">          (</span><span style="color:#9ECBFF">"Computed property </span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> key </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF"> was assigned to but it has no setter."</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#79B8FF">          this</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">      };</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    Object.</span><span style="color:#B392F0">defineProperty</span><span style="color:#E1E4E8">(target, key, sharedPropertyDefinition);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="computed流程图">computed流程图</h3>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1072" height="734" src="/_astro/vue2-init-computed.Cfm1Vo9i_VkV15.webp" ></p>
<h3 id="createcomputedgetter">createComputedGetter</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> createComputedGetter</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> computedGetter</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">      // _computedWatchers在Vue</span></span>
<span class="line"><span style="color:#6A737D">      // this指的是vm，即当前组件实例</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> watcher </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">._computedWatchers </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">._computedWatchers[key];</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (watcher) {</span></span>
<span class="line"><span style="color:#6A737D">        // 缓存控制</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (watcher.dirty) {</span></span>
<span class="line"><span style="color:#6A737D">          // 调用evaluate后dirty会变成false</span></span>
<span class="line"><span style="color:#E1E4E8">          watcher.</span><span style="color:#B392F0">evaluate</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">          // dep.notify => update() => this.dirty=true</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (Dep.target) {</span></span>
<span class="line"><span style="color:#E1E4E8">          watcher.</span><span style="color:#B392F0">depend</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> watcher.value</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="creategetterinvoker">createGetterInvoker</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> createGetterInvoker</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fn</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> computedGetter</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> fn.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h2 id="initwatch">initWatch</h2>
<div class="custom-container tip"><p class="custom-container-title">initWatch流程</p><pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#B392F0">watch</span><span style="color:#E1E4E8">:{</span></span>
<span class="line"><span style="color:#B392F0">  message</span><span style="color:#E1E4E8">(newVal, oldVal){</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(newVal, oldVal)</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre><p>假设<code>watch</code>是上面的数据，遍历<code>key</code>，由于<code>watch</code>可以多种写法，字符串、函数、对象、数组形式，最终导出回调函数，并取到表达式<code>message</code>，然后实例化一个<code>Watcher</code>，在实例化的过程成中会调用<code>this.get()</code>，然后就执行<code>message</code>的<code>getter</code>，就执行<code>dep.depend</code>，依赖就被存储了，然后判断<code>immediate</code>是否为<code>true</code>，是的话直接执行回调函数。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> initWatch</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">vm</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Component</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">watch</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Object</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> key</span><span style="color:#F97583"> in</span><span style="color:#E1E4E8"> watch) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> handler</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> watch[key]</span></span>
<span class="line"><span style="color:#6A737D">    // 判断是否是数组，是的话就遍历，可以写成</span></span>
<span class="line"><span style="color:#6A737D">    // watch: {</span></span>
<span class="line"><span style="color:#6A737D">    //   message: {</span></span>
<span class="line"><span style="color:#6A737D">    //     [{</span></span>
<span class="line"><span style="color:#6A737D">    //       handle: 'init'</span></span>
<span class="line"><span style="color:#6A737D">    //     },</span></span>
<span class="line"><span style="color:#6A737D">    //     {</span></span>
<span class="line"><span style="color:#6A737D">    //       handle: 'init'</span></span>
<span class="line"><span style="color:#6A737D">    //     }]</span></span>
<span class="line"><span style="color:#6A737D">    //   }</span></span>
<span class="line"><span style="color:#6A737D">    // }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(handler)) {</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> handler.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">        createWatcher</span><span style="color:#E1E4E8">(vm, key, handler[i])</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      createWatcher</span><span style="color:#E1E4E8">(vm, key, handler)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="createwatcher">createWatcher</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createWatcher</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#FFAB70">  vm</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Component</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">  expOrFn</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#F97583"> |</span><span style="color:#B392F0"> Function</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">  handler</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> any</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">  options</span><span style="color:#F97583">?:</span><span style="color:#B392F0"> Object</span></span>
<span class="line"><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isPlainObject</span><span style="color:#E1E4E8">(handler)) {</span></span>
<span class="line"><span style="color:#E1E4E8">    options </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> handler</span></span>
<span class="line"><span style="color:#E1E4E8">    handler </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> handler.handler</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#6A737D">  // 说明handle可以传字符串 handle: 'init'，init是method中的一函数</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> handler </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'string'</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 从当前组件中获取属性</span></span>
<span class="line"><span style="color:#E1E4E8">    handler </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm[handler]</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> vm.</span><span style="color:#B392F0">$watch</span><span style="color:#E1E4E8">(expOrFn, handler, options)</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="vmwatch">vm.$watch</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">  Vue</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">$watch</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#FFAB70">    expOrFn</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> string</span><span style="color:#F97583"> |</span><span style="color:#B392F0"> Function</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    cb</span><span style="color:#F97583">:</span><span style="color:#79B8FF"> any</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    options</span><span style="color:#F97583">?:</span><span style="color:#B392F0"> Object</span></span>
<span class="line"><span style="color:#E1E4E8">  )</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Function</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> vm</span><span style="color:#F97583">:</span><span style="color:#B392F0"> Component</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isPlainObject</span><span style="color:#E1E4E8">(cb)) {</span></span>
<span class="line"><span style="color:#6A737D">      // 如果handle是对象的话就再次执行createWatcher,看下面代码有三层handler，</span></span>
<span class="line"><span style="color:#6A737D">      // 其实再多几层也可以，这边会递归handle，所以最终传入到$watch的时候，cb肯定不是个对象了</span></span>
<span class="line"><span style="color:#6A737D">      // watch:{</span></span>
<span class="line"><span style="color:#6A737D">      //   message:{</span></span>
<span class="line"><span style="color:#6A737D">      //     handler: {</span></span>
<span class="line"><span style="color:#6A737D">      //       handler: {</span></span>
<span class="line"><span style="color:#6A737D">      //         handler: 'init'</span></span>
<span class="line"><span style="color:#6A737D">      //         immediate: true</span></span>
<span class="line"><span style="color:#6A737D">      //         },</span></span>
<span class="line"><span style="color:#6A737D">      //       },</span></span>
<span class="line"><span style="color:#6A737D">      //     },</span></span>
<span class="line"><span style="color:#6A737D">      //   },</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#B392F0"> createWatcher</span><span style="color:#E1E4E8">(vm, expOrFn, cb, options)</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    options </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> {}</span></span>
<span class="line"><span style="color:#E1E4E8">    options.user </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#6A737D">    // 在dep为message的对象中添加订阅，dep.subs添加该watcher</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> watcher</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Watcher</span><span style="color:#E1E4E8">(vm, expOrFn, cb, options)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (options.immediate) {</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        cb.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(vm, watcher.value)</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (error) {</span></span>
<span class="line"><span style="color:#B392F0">        handleError</span><span style="color:#E1E4E8">(error, vm, </span><span style="color:#9ECBFF">`callback for immediate watcher "${</span><span style="color:#E1E4E8">watcher</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">expression</span><span style="color:#9ECBFF">}"`</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> unwatchFn</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">      watcher.</span><span style="color:#B392F0">teardown</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="476" height="806" src="/_astro/vue2-init-watch.B9nBdPDT_Z1vCfRp.webp" ></p>
<h2 id="observe判断是否需要观察">observe（判断是否需要观察）</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>尝试为value创建一个观察者实例，如果成功就返回新Observer的实例或返回当前已存在Observer</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> observe</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">asRootData</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  // 判断是否是对象 || 这个对象是否是 VNode</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#B392F0">isObject</span><span style="color:#E1E4E8">(value) </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">instanceof</span><span style="color:#B392F0"> VNode</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> ob;</span></span>
<span class="line"><span style="color:#6A737D">  // 如果这个对象有__ob__属性 &#x26;&#x26; __ob__属性是Observer的实例，就将__ob__赋值给ob</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">hasOwn</span><span style="color:#E1E4E8">(value, </span><span style="color:#9ECBFF">'__ob__'</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> value.__ob__ </span><span style="color:#F97583">instanceof</span><span style="color:#B392F0"> Observer</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    ob </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> value.__ob__;</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#6A737D">    // 如果应该观察 &#x26;&#x26; 不是服务端渲染 &#x26;&#x26; （这个值是个数组 || 这个值是个纯对象）&#x26;&#x26; 对象是可以扩展的 &#x26;&#x26; value._isVue的值是false(只有根vm._isVue = true)</span></span>
<span class="line"><span style="color:#E1E4E8">    shouldObserve </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#F97583">    !</span><span style="color:#B392F0">isServerRendering</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">    (Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(value) </span><span style="color:#F97583">||</span><span style="color:#B392F0"> isPlainObject</span><span style="color:#E1E4E8">(value)) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">isExtensible</span><span style="color:#E1E4E8">(value) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">value._isVue</span></span>
<span class="line"><span style="color:#E1E4E8">  ) {</span></span>
<span class="line"><span style="color:#E1E4E8">    ob </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Observer</span><span style="color:#E1E4E8">(value);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> ob</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>如果符合上面一系列条件后会跳到Observe进行实例化,点击<a style="color:rgb(122, 214, 253);" href="#observer（观察属性，并替换数组的-proto-）">Observer</a>跳到函数实现。</p>
<h2 id="definereactive1">defineReactive$$1</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>传入对象和属性名，来设置<code>defineProperty</code>的<code>setter</code>、<code>getter</code>，每次定义前都会new Dep来定义当前数据的Dep，用来保存该数据对应更新user watcher、computed、渲染watcher。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">// 声明一个响应式对象</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> defineReactive$$1</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#FFAB70">    obj</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    key</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    val</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    customSetter</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    shallow</span></span>
<span class="line"><span style="color:#E1E4E8">  ) {</span></span>
<span class="line"><span style="color:#6A737D">    // 实例化一个dep</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> dep </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Dep</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // // 获取对应属性的描述符</span></span>
<span class="line"><span style="color:#6A737D">    // getOwnPropertyDescriptor</span></span>
<span class="line"><span style="color:#6A737D">    // {</span></span>
<span class="line"><span style="color:#6A737D">    //   configurable: Boolean</span></span>
<span class="line"><span style="color:#6A737D">    //   enumerable: Boolean</span></span>
<span class="line"><span style="color:#6A737D">    //   value: ''</span></span>
<span class="line"><span style="color:#6A737D">    //   writable: Boolean</span></span>
<span class="line"><span style="color:#6A737D">    // }</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> property </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">getOwnPropertyDescriptor</span><span style="color:#E1E4E8">(obj, key);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (property </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> property.configurable </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      return</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 获取预设定的getter、setter</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> getter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> property </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> property.get;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> setter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> property </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> property.set;</span></span>
<span class="line"><span style="color:#6A737D">    // 如果传入参数只有两个，说明没有传val，就调用obj[key]</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ((</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">getter </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> setter) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#79B8FF"> arguments</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      val </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> obj[key];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // shallow表示浅的意思，只在定义 $attrs和$listeners是true，其他都默认为false，便会递归观察对象</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> childOb </span><span style="color:#F97583">=</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">shallow </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> observe</span><span style="color:#E1E4E8">(val);</span></span>
<span class="line"><span style="color:#E1E4E8">    Object.</span><span style="color:#B392F0">defineProperty</span><span style="color:#E1E4E8">(obj, key, {</span></span>
<span class="line"><span style="color:#E1E4E8">      enumerable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">      configurable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">      get</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#B392F0"> reactiveGetter</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#6A737D">        // 判断是否有getter，有getter优先调用，在data中定义的是没有getter的</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getter </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> getter.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj) </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#6A737D">        // 在Watcher.get中会触发pushTarget(this);然后将当前的watcher推入全局栈targetStack中，并且将静态变量Dep.target赋值为当前的watcher</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (Dep.target) {</span></span>
<span class="line"><span style="color:#E1E4E8">          dep.</span><span style="color:#B392F0">depend</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (childOb) {</span></span>
<span class="line"><span style="color:#E1E4E8">            childOb.dep.</span><span style="color:#B392F0">depend</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(value)) {</span></span>
<span class="line"><span style="color:#B392F0">              dependArray</span><span style="color:#E1E4E8">(value);</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">          }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8"> value</span></span>
<span class="line"><span style="color:#E1E4E8">      },</span></span>
<span class="line"><span style="color:#B392F0">      set</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#B392F0"> reactiveSetter</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">newVal</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getter </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> getter.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj) </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#6A737D">        // 如果旧值和新值全等直接return</span></span>
<span class="line"><span style="color:#6A737D">        // (newVal !== newVal &#x26;&#x26; value !== value)用来判断 是否是NaN，如果是NaN直接return</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (newVal </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> (newVal </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> newVal </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> value </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> value)) {</span></span>
<span class="line"><span style="color:#F97583">          return</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#6A737D">        // 如果有自定义setter就执行setter</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (customSetter) {</span></span>
<span class="line"><span style="color:#B392F0">          customSetter</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (getter </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">setter) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (setter) {</span></span>
<span class="line"><span style="color:#E1E4E8">          setter.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj, newVal);</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">          val </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> newVal;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#6A737D">        // 如果shallow为undefined或false就把新值扔进observer判断是否需要观察</span></span>
<span class="line"><span style="color:#E1E4E8">        childOb </span><span style="color:#F97583">=</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">shallow </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> observe</span><span style="color:#E1E4E8">(newVal);</span></span>
<span class="line"><span style="color:#6A737D">        // 通知当前dep依赖的watcher更新</span></span>
<span class="line"><span style="color:#E1E4E8">        dep.</span><span style="color:#B392F0">notify</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p><strong>上面在data里面每个对象挂载了setter、getter方法，但是在之前的proxy也有挂载getter、setter方法，会不会被覆盖呢？</strong></p>
<p>答案是不会，因为<code>Object.defineProperty(obj, key)</code>中虽然key相同，但是obj是不同的，所以两次挂载是不重复，第一次在proxy中设置getter、setter是为了新建一个内存空间来放入getter、setter的值用的，这边是为了截取用户调用data中属性而设置的getter、setter。
<img __ASTRO_IMAGE_="{&#x22;src&#x22;:&#x22;./Vue2-defineReactive-getter&#x26;setter.png&#x22;,&#x22;alt&#x22;:&#x22;&#x22;,&#x22;index&#x22;:0}"></p>
<ul>
<li>
<p>如果你是按照流程走，现在已经走完<code>initData()</code>了，返回<a style="color:rgb(122, 214, 253);" href="#initstate">initState</a>继续走<a style="color:rgb(122, 214, 253);" href="#initcomputed">initComputed</a></p>
</li>
<li>
<p>如果你是从<code>this.getter.call</code>跳过来的话，执行的是<code>getter</code>函数，里面先判断Dep.targt是否存在，然后就开始建立关系<a style="color:rgb(122, 214, 253);" href="#dep-prototype-depend">dep.depend()</a></p>
</li>
</ul>
<h2 id="observer观察属性并替换数组的__proto__">Observer（观察属性，并替换数组的__proto__）</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>附加到每个观察对象的观察者类。一旦附加，观察者将目标对象的属性键转换为<code>getter/setter</code>，用于收集依赖项和分配更新。与<code>Dep</code>类共同工作才能完成数据更新。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#B392F0"> Observer</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> Observer</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">value</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> value;</span></span>
<span class="line"><span style="color:#6A737D">    // 实例化一个dep</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dep </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Dep</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.vmCount </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">    // 在value上面添加__ob__这个属性并指向this</span></span>
<span class="line"><span style="color:#B392F0">    def</span><span style="color:#E1E4E8">(value, </span><span style="color:#9ECBFF">'__ob__'</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(value)) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (hasProto) {</span></span>
<span class="line"><span style="color:#6A737D">        // protoAugment => value.__proto__ = arrayMethods</span></span>
<span class="line"><span style="color:#6A737D">        // arrayMethods 重点分支，基于Array.__proto__新建一个原型链，然后劫持用户对数组的操作</span></span>
<span class="line"><span style="color:#B392F0">        protoAugment</span><span style="color:#E1E4E8">(value, arrayMethods);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // 忽略</span></span>
<span class="line"><span style="color:#B392F0">        copyAugment</span><span style="color:#E1E4E8">(value, arrayMethods, arrayKeys);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">observeArray</span><span style="color:#E1E4E8">(value);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">walk</span><span style="color:#E1E4E8">(value);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<p>上面用到的函数:</p>
<ol>
<li><a style="color:rgb(122, 214, 253);" href="#def">def</a>在对象上面添加或修改属性</li>
<li><a style="color:rgb(122, 214, 253);" href="#arraymethods">arrayMethods</a>拦截用户对数组的操作，并且通知这些数据变换依赖的watcher</li>
<li><a style="color:rgb(122, 214, 253);" href="#observearray">Observer.observeArray</a>遍历数组调用observe</li>
<li><a style="color:rgb(122, 214, 253);" href="#walk">Observer.walk</a>遍历对象中所有属性来调用<code>defineReactive$$1</code></li>
</ol>
<h3 id="walk">walk</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">  // 遍历所有属性并将它们转换为getter/setter。此方法只应在值类型为Object时调用。</span></span>
<span class="line"><span style="color:#79B8FF">  Observer</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">walk</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> walk</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> keys </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">keys</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> keys.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">      defineReactive$$1</span><span style="color:#E1E4E8">(obj, keys[i]);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<p><code>defineReactive$$1()</code>给对象设置getter、setter，点击<a style="color:rgb(122, 214, 253);" href="#definereactive-1">defineReactive$$1</a>跳转函数实现。</p>
<h3 id="observearray">observeArray</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">// 遍历数组调用observe</span></span>
<span class="line"><span style="color:#79B8FF">  Observer</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">observeArray</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> observeArray</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">items</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, l </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> items.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> l; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">      observe</span><span style="color:#E1E4E8">(items[i]);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<h2 id="arraymethods">arrayMethods</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>基于<code>Array.prototype</code>新建一个原型链，拦截用户对数组的操作，并且通知这些数据变换依赖的watcher。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">    // 获取原生Array中提供的所有方法</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> arrayProto </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> Array</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">    // 将原生提供的方法创建一个新的对象，以免修改原生的方法，造成全局污染</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> arrayMethods </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(arrayProto);</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> methodsToPatch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [</span></span>
<span class="line"><span style="color:#9ECBFF">    'push'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'pop'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'shift'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'unshift'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'splice'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'sort'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#9ECBFF">    'reverse'</span></span>
<span class="line"><span style="color:#E1E4E8">  ];</span></span>
<span class="line"><span style="color:#6A737D">  /**</span></span>
<span class="line"><span style="color:#6A737D">   * 截取上面这些方法，然后实现相应的操作</span></span>
<span class="line"><span style="color:#6A737D">   */</span></span>
<span class="line"><span style="color:#E1E4E8">  methodsToPatch.</span><span style="color:#B392F0">forEach</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">method</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 缓存原始方法，也就是Array的原型方法原本的实现</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> original </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> arrayProto[method];</span></span>
<span class="line"><span style="color:#B392F0">    def</span><span style="color:#E1E4E8">(arrayMethods, method, </span><span style="color:#F97583">function</span><span style="color:#B392F0"> mutator</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#6A737D">      // 截取用户调用Array.methods传入的参数args</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> args </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [], len </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> arguments</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      while</span><span style="color:#E1E4E8"> ( len</span><span style="color:#F97583">--</span><span style="color:#E1E4E8"> ) args[ len ] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> arguments</span><span style="color:#E1E4E8">[ len ];</span></span>
<span class="line"><span style="color:#6A737D">      // 在函数体内优先调用了缓存下来的数组变异方法</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> original.</span><span style="color:#B392F0">apply</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">, args);</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> ob </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.__ob__;</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> inserted;</span></span>
<span class="line"><span style="color:#6A737D">      // 可以看到这个switch里面的方法:push、unshift、splice都是增加数组元素的方法</span></span>
<span class="line"><span style="color:#F97583">      switch</span><span style="color:#E1E4E8"> (method) {</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#9ECBFF"> 'push'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#9ECBFF"> 'unshift'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">          inserted </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> args;</span></span>
<span class="line"><span style="color:#F97583">          break</span></span>
<span class="line"><span style="color:#F97583">        case</span><span style="color:#9ECBFF"> 'splice'</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">          inserted </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> args.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">          break</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // // 如果有修改的数据，则添加observer监听器</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (inserted) { ob.</span><span style="color:#B392F0">observeArray</span><span style="color:#E1E4E8">(inserted); }</span></span>
<span class="line"><span style="color:#6A737D">      // 通知更新</span></span>
<span class="line"><span style="color:#E1E4E8">      ob.dep.</span><span style="color:#B392F0">notify</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> result</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span></code></pre>
<h2 id="公用函数">公用函数</h2>
<h3 id="setscope">setScope</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">// 给scoped CSS 设置范围id属性</span></span>
<span class="line"><span style="color:#6A737D">//</span></span>
<span class="line"><span style="color:#F97583">    function</span><span style="color:#B392F0"> setScope</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">vnode</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isDef</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vnode.fnScopeId)) {</span></span>
<span class="line"><span style="color:#E1E4E8">        nodeOps.</span><span style="color:#B392F0">setStyleScope</span><span style="color:#E1E4E8">(vnode.elm, i);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> ancestor </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vnode;</span></span>
<span class="line"><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (ancestor) {</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isDef</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ancestor.context) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> isDef</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i.$options._scopeId)) {</span></span>
<span class="line"><span style="color:#E1E4E8">            nodeOps.</span><span style="color:#B392F0">setStyleScope</span><span style="color:#E1E4E8">(vnode.elm, i);</span></span>
<span class="line"><span style="color:#E1E4E8">          }</span></span>
<span class="line"><span style="color:#E1E4E8">          ancestor </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ancestor.parent;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // for slot content they should also get the scopeId from the host instance.</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isDef</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> activeInstance) </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">        i </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> vnode.context </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#E1E4E8">        i </span><span style="color:#F97583">!==</span><span style="color:#E1E4E8"> vnode.fnContext </span><span style="color:#F97583">&#x26;&#x26;</span></span>
<span class="line"><span style="color:#B392F0">        isDef</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i.$options._scopeId)</span></span>
<span class="line"><span style="color:#E1E4E8">      ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        nodeOps.</span><span style="color:#B392F0">setStyleScope</span><span style="color:#E1E4E8">(vnode.elm, i);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span></code></pre>
<h3 id="isdef">isDef</h3>
<div class="custom-container tip"><p class="custom-container-title">用法与作用</p><p>传入一个变量，判断是否是<code>undefined</code>且<code>null</code></p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> isDef</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">v</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> undefined</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8"> v </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="def">def</h3>
<div class="custom-container tip"><p class="custom-container-title">def</p><p>传入<code>obj, key, val, enumerable</code><br>
在对象上面添加或修改属性</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">/**</span></span>
<span class="line"><span style="color:#6A737D"> * Define a property.</span></span>
<span class="line"><span style="color:#6A737D"> */</span></span>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> def</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">enumerable</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  Object.</span><span style="color:#B392F0">defineProperty</span><span style="color:#E1E4E8">(obj, key, {</span></span>
<span class="line"><span style="color:#E1E4E8">    value: val,</span></span>
<span class="line"><span style="color:#E1E4E8">    enumerable: </span><span style="color:#F97583">!!</span><span style="color:#E1E4E8">enumerable,</span></span>
<span class="line"><span style="color:#E1E4E8">    writable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    configurable: </span><span style="color:#79B8FF">true</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="traverse">traverse</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>递归遍历一个对象中的所有属性，取到当前值时就触发了getter，在getter中建立依赖。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> traverse</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // seenObjects是一个set，在递归的过程中存入depId，碰到已经监听的dep就跳过</span></span>
<span class="line"><span style="color:#B392F0">    _traverse</span><span style="color:#E1E4E8">(val, seenObjects);</span></span>
<span class="line"><span style="color:#E1E4E8">    seenObjects.</span><span style="color:#B392F0">clear</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> _traverse</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">seen</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> i, keys;</span></span>
<span class="line"><span style="color:#6A737D">    // 在这里调用val，触发了getter => dep.depend</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> isA </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(val);</span></span>
<span class="line"><span style="color:#6A737D">    // isFrozen判断不可扩展，响应式数据都是可扩展的</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ((</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">isA </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#B392F0">isObject</span><span style="color:#E1E4E8">(val)) </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">isFrozen</span><span style="color:#E1E4E8">(val) </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> val </span><span style="color:#F97583">instanceof</span><span style="color:#B392F0"> VNode</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      return</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (val.__ob__) {</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> depId </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> val.__ob__.dep.id;</span></span>
<span class="line"><span style="color:#6A737D">      // 碰到已经监听过的dep就跳过</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (seen.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(depId)) {</span></span>
<span class="line"><span style="color:#F97583">        return</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">      seen.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(depId);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 遍历数组，递归数组的值</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (isA) {</span></span>
<span class="line"><span style="color:#E1E4E8">      i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> val.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      while</span><span style="color:#E1E4E8"> (i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) { </span><span style="color:#B392F0">_traverse</span><span style="color:#E1E4E8">(val[i], seen); }</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      keys </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">keys</span><span style="color:#E1E4E8">(val);</span></span>
<span class="line"><span style="color:#E1E4E8">      i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> keys.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">      // 遍历对象的每个属性</span></span>
<span class="line"><span style="color:#F97583">      while</span><span style="color:#E1E4E8"> (i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) { </span><span style="color:#B392F0">_traverse</span><span style="color:#E1E4E8">(val[keys[i]], seen); }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="hasown">hasOwn</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>判断这个对象有没有这个属性</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> hasOwnProperty </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> Object</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.hasOwnProperty;</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> hasOwn</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> hasOwnProperty.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(obj, key)</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="shouldobserve">shouldObserve</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>在某些情况下，我们可能想要禁止组件中更新计算中的观察。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> shouldObserve </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> toggleObserving</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">value</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    shouldObserve </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> value;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="proxy">proxy</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>将target的key属性的值代理到sourceKey中的属性key。结论：取target中的key就是取sourceKey中的key,例如<code>vm.message = '123'</code>触发set函数<code>vm._data.message = '123'</code></p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> sharedPropertyDefinition </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    enumerable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    configurable: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    get: noop,</span></span>
<span class="line"><span style="color:#E1E4E8">    set: noop</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> proxy</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">target</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">sourceKey</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    sharedPropertyDefinition.</span><span style="color:#B392F0">get</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> proxyGetter</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">[sourceKey][key]</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">    sharedPropertyDefinition.</span><span style="color:#B392F0">set</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> proxySetter</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">[sourceKey][key] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#6A737D">    // 这边的target是vm，在defineReactive$$1中也有设置get、set，那里面的target是我们定义的data对象</span></span>
<span class="line"><span style="color:#E1E4E8">    Object.</span><span style="color:#B392F0">defineProperty</span><span style="color:#E1E4E8">(target, key, sharedPropertyDefinition);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p>下面这个例子讲的是，我们平时在取<code>this.message</code>的时候其实取的是<code>this._data.messgae</code>，当前setter也是一样的效果。
<img __ASTRO_IMAGE_="{&#x22;src&#x22;:&#x22;./Vue2-proxy-getter&#x26;setter.png&#x22;,&#x22;alt&#x22;:&#x22;&#x22;,&#x22;index&#x22;:0}"></p>
<h2 id="dep与watcher">Dep与Watcher</h2>
<div class="custom-container tip"><p class="custom-container-title">联系</p><ul>
<li>dep与watcher是多对多的关系，watcher负责包含页面的变化函数，dep</li>
<li>watcher：一个表达式对应一个Watcher，一个watcher可能对应多个Dep（多层表达式：foo.test.one）</li>
<li>dep：一个dep可能对应多个watcher，属性可能在模板中被多次使用到(比如：<br></li>
</ul><!-- <p>{{message}}</p><br> --><!-- <div>{{message}}</div><br> --><!-- computed:{test(){return this.message + '22'}}<br> --><br></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#B392F0">data</span><span style="color:#E1E4E8">:{</span></span>
<span class="line"><span style="color:#B392F0">  message</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">'hello'</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.message </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> 'world'</span></span>
<span class="line"><span style="color:#6A737D">// 上面的执行顺序是：</span></span>
<span class="line"><span style="color:#6A737D">// 1. vm.message = 'world' => 在initData中已经代理过，vm._data.message 和 vm.message引用地址是一个</span></span>
<span class="line"><span style="color:#6A737D">// 2. vm._data.message = 'world'</span></span>
<span class="line"><span style="color:#6A737D">// 3. 触发vm._data的setter函数</span></span>
<span class="line"><span style="color:#6A737D">// 4. 在setter函数中触发dep.notify();引发页面更新</span></span></code></pre>
<h3 id="dep">Dep</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>defineReactive方法将data中的数据进行响应式后，可以监听到数据的变化了,然后Dep就是帮我们收集依赖究竟要通知到哪里。每单个对象（递归遍历）对应一个Dep类。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">// 为了让更好的订阅watcher，每个数据对象都有唯一的uid，</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> uid </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#B392F0"> Dep</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> Dep</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> uid</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.subs </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<h3 id="addsubremovesub">addSub&#x26;&#x26;removeSub</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF"> Dep</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">addSub</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> addSub</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">sub</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 将watcher放入该数据订阅的subs数组中，当该数据更新会通知所有已订阅的watcher更新。</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.subs.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(sub);</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#79B8FF">  Dep</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">. </span><span style="color:#F97583">=</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> removeSub</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">sub</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    remove</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.subs, sub);</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<h3 id="depprototypedepend">Dep.prototype.depend</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">  Dep</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">depend</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> depend</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (Dep.target) {</span></span>
<span class="line"><span style="color:#6A737D">      // 执行Watcher.prototype.addDep并把当前dep实例作为参数带入</span></span>
<span class="line"><span style="color:#E1E4E8">      Dep.target.</span><span style="color:#B392F0">addDep</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<p><code>Dep.target</code>指的是当前<code>watcher</code>，继续走<a style="color:rgb(122, 214, 253);" href="#watcher-prototype-adddep">Dep.target.addDep(this)</a></p>
<h3 id="depprototypenotify">Dep.prototype.notify</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">  Dep</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">notify</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> notify</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> subs </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.subs.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">      // 异步执行更新 默认情况下config.async = true，异步更新性能较好</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">config.async) {</span></span>
<span class="line"><span style="color:#E1E4E8">      subs.</span><span style="color:#B392F0">sort</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">a</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">b</span><span style="color:#E1E4E8">) { </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> a.id </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> b.id; });</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, l </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> subs.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> l; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      subs[i].</span><span style="color:#B392F0">update</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<h3 id="pushtargetpoptarget">pushTarget&#x26;&#x26;popTarget</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#6A737D">  // 当首次计算 computed 属性的值时，Dep将会在计算期间对依赖进行收集</span></span>
<span class="line"><span style="color:#E1E4E8">  Dep.target </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">  // 设置成数组的原因是：可能会有对象嵌套</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> targetStack </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#6A737D">  // target指的是watcher</span></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> pushTarget</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">target</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // 在一次依赖收集期间，如果有其他依赖收集任务开始（比如：当前 computed 计算属性嵌套其他 computed 计算属性），</span></span>
<span class="line"><span style="color:#6A737D">    // 那么将会把当前 target 暂存到 targetStack，先进行其他 target 的依赖收集，</span></span>
<span class="line"><span style="color:#E1E4E8">    targetStack.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(target);</span></span>
<span class="line"><span style="color:#E1E4E8">    Dep.target </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> target;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> popTarget</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">    // 当嵌套的依赖收集任务完成后，将target恢复为上一层的Wacther</span></span>
<span class="line"><span style="color:#E1E4E8">    targetStack.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    Dep.target </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> targetStack[targetStack.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h2 id="watcher">Watcher</h2>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>Watcher负责</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> Watcher</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> Watcher</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#FFAB70">    vm</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    expOrFn</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    cb</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    options</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#FFAB70">    isRenderWatcher</span></span>
<span class="line"><span style="color:#E1E4E8">  ) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.vm </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> vm;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (isRenderWatcher) {</span></span>
<span class="line"><span style="color:#E1E4E8">      vm._watcher </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    vm._watchers.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">    // options</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (options) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.deep </span><span style="color:#F97583">=</span><span style="color:#F97583"> !!</span><span style="color:#E1E4E8">options.deep;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.user </span><span style="color:#F97583">=</span><span style="color:#F97583"> !!</span><span style="color:#E1E4E8">options.user;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.lazy </span><span style="color:#F97583">=</span><span style="color:#F97583"> !!</span><span style="color:#E1E4E8">options.lazy;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.sync </span><span style="color:#F97583">=</span><span style="color:#F97583"> !!</span><span style="color:#E1E4E8">options.sync;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.before </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options.before;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.deep </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.user </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lazy </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.sync </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.cb </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> cb;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.id </span><span style="color:#F97583">=</span><span style="color:#F97583"> ++</span><span style="color:#E1E4E8">uid$2; </span><span style="color:#6A737D">// uid for batching</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.active </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#6A737D">    //  lazy 表示一种固定描述，不可改变，表示这个 watcher 需要缓存</span></span>
<span class="line"><span style="color:#6A737D">    // dirty 表示缓存是否可用，如果为 true，表示缓存脏了，需要重新计算，否则不用</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dirty </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lazy; </span><span style="color:#6A737D">// for lazy watchers</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.deps </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDeps </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.depIds </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> _Set</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDepIds </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> _Set</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.expression </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> expOrFn.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // parse expression for getter</span></span>
<span class="line"><span style="color:#6A737D">    // 接收计算函数的getter</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> expOrFn </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> 'function'</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.getter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> expOrFn;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.getter </span><span style="color:#F97583">=</span><span style="color:#B392F0"> parsePath</span><span style="color:#E1E4E8">(expOrFn);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.getter) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.getter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> noop;</span></span>
<span class="line"><span style="color:#B392F0">        warn</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">          "Failed watching path: </span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF">"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> expOrFn </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\"</span><span style="color:#9ECBFF"> "</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">          'Watcher only accepts simple dot-delimited paths. '</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">          'For full control, use a function instead.'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">          vm</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lazy</span></span>
<span class="line"><span style="color:#F97583">      ?</span><span style="color:#79B8FF"> undefined</span></span>
<span class="line"><span style="color:#F97583">      :</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">      // get是个重要分支</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"><span style="color:#6A737D">  // 调用this.get方法，并将dirty设置成false，防止再次调用</span></span>
<span class="line"><span style="color:#79B8FF">    Watcher</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">evaluate</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> evaluate</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.value </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">get</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dirty </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<h3 id="watcherprototypeget">watcher.prototype.get</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#B392F0">  get</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#6A737D">    // 将当前的watcher推入栈中，为后面的添加依赖做铺垫</span></span>
<span class="line"><span style="color:#6A737D">    // Dep.target = this</span></span>
<span class="line"><span style="color:#B392F0">    pushTarget</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> value</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> vm</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.vm</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">      // 调用getter =》 dep.depend(); 这一步将是将Dep.target推入到dep中</span></span>
<span class="line"><span style="color:#E1E4E8">      value </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.getter.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(vm, vm)</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (e) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.user) {</span></span>
<span class="line"><span style="color:#B392F0">        handleError</span><span style="color:#E1E4E8">(e, vm, </span><span style="color:#9ECBFF">`getter for watcher "${</span><span style="color:#79B8FF">this</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">expression</span><span style="color:#9ECBFF">}"`</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        throw</span><span style="color:#E1E4E8"> e</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">finally</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">      // "touch" every property so they are all tracked as</span></span>
<span class="line"><span style="color:#6A737D">      // dependencies for deep watching</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.deep) {</span></span>
<span class="line"><span style="color:#B392F0">        traverse</span><span style="color:#E1E4E8">(value)</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // 撤销当前Dep.target</span></span>
<span class="line"><span style="color:#B392F0">      popTarget</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#6A737D">      // 代码解释在下面</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">cleanupDeps</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> value</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p><code>value = this.getter.call(vm, vm)</code>最终会跳到会跳到<code>defineReactive</code>中定义的getter函数，<a style="color:rgb(122, 214, 253);" href="##definereactive-1">definereactive-get</a></p>
<h3 id="watcherprototypeadddep">watcher.prototype.addDep</h3>
<div class="custom-container tip"><p class="custom-container-title">addDep</p><p>在执行<code>dep.depend()</code>之前一般都会先执行<code>pushTarget()</code>，将当前的<code>watcher</code>推到全局变量<code>targetStack</code>的栈中，并且把<code>Dep.target</code>赋值为当前推入的<code>watcher</code>，然后就开始想户建立建立关系，建立关系的代码就在下面。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">  Watcher</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">addDep</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> addDep</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">dep</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> dep.id;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(id)) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(id);</span></span>
<span class="line"><span style="color:#6A737D">      // watcher中放入dep</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.newDeps.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(dep);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.depIds.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(id)) {</span></span>
<span class="line"><span style="color:#6A737D">        // dep中放入watcher</span></span>
<span class="line"><span style="color:#E1E4E8">        dep.</span><span style="color:#B392F0">addSub</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<p>执行到<a style="color:rgb(122, 214, 253);" href="#addsub-removesub">dep.addSub(this)</a></p>
<h3 id="cleanupdeps">cleanupDeps</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p><code>addDep</code>的作用是将关系放入<code>newDepIds</code>、<code>newDeps</code>中，而<code>cleanupDeps</code>是将新的Dep与旧的Dep做判断，如果新的依赖集合里面没有以前旧的，就把dep已经订阅的watcher移除，然后将<code>newDepIds</code>、<code>newDeps</code>转到<code>depIds</code>,<code>deps</code>，并置空<code>newDepIds</code>、<code>newDeps</code>。听起来有点绕口，下面有个例子:<a style="color:rgb(122, 214, 253);" href="#如何建立联系">如何建立联系</a></p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.deps.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // 判断最新的</span></span>
<span class="line"><span style="color:#F97583">      var</span><span style="color:#E1E4E8"> dep </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.deps[i];</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(dep.id)) {</span></span>
<span class="line"><span style="color:#E1E4E8">        dep.</span><span style="color:#B392F0">removeSub</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 利用一个额外空间来newDepIds 转到 depIds，并清空newDepIds</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> tmp </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.depIds;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.depIds </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.newDepIds;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDepIds </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tmp;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">clear</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // 利用一个额外空间来newDeps 转到 deps，并清空newDeps</span></span>
<span class="line"><span style="color:#E1E4E8">    tmp </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.deps;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.deps </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.newDeps;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDeps </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tmp;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.newDeps.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="queuewatcher">queueWatcher</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><ul>
<li>推入一个watcher到当前队列queue</li>
<li>根据watcher的id来判断，确保不会重复</li>
</ul></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> queueWatcher</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">watcher</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> watcher.id;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (has[id] </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      has[id] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">flushing) {</span></span>
<span class="line"><span style="color:#E1E4E8">        queue.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(watcher);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">        // if already flushing, splice the watcher based on its id</span></span>
<span class="line"><span style="color:#6A737D">        // if already past its id, it will be run next immediately.</span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> queue.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">        while</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> index </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> queue[i].id </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> watcher.id) {</span></span>
<span class="line"><span style="color:#E1E4E8">          i</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">        queue.</span><span style="color:#B392F0">splice</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, watcher);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#6A737D">      // queue the flush</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">waiting) {</span></span>
<span class="line"><span style="color:#E1E4E8">        waiting </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">config.async) {</span></span>
<span class="line"><span style="color:#B392F0">          flushSchedulerQueue</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">          return</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#B392F0">        nextTick</span><span style="color:#E1E4E8">(flushSchedulerQueue);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p>举个例子：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="html"><code><span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#85E89D">body</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">div</span><span style="color:#B392F0"> id</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"app"</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;</span><span style="color:#85E89D">p</span><span style="color:#B392F0"> ref</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"message"</span><span style="color:#E1E4E8">>{{message}}&#x3C;/</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;</span><span style="color:#85E89D">p</span><span style="color:#B392F0"> ref</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"code"</span><span style="color:#E1E4E8">>{{code}}&#x3C;/</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">>{{realArr}}&#x3C;/</span><span style="color:#85E89D">p</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">        &#x3C;</span><span style="color:#85E89D">button</span><span style="color:#B392F0"> @click</span><span style="color:#E1E4E8">=</span><span style="color:#9ECBFF">"onClick"</span><span style="color:#E1E4E8">>click&#x3C;/</span><span style="color:#85E89D">button</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;/</span><span style="color:#85E89D">div</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#E1E4E8">    &#x3C;</span><span style="color:#85E89D">script</span><span style="color:#E1E4E8">></span></span>
<span class="line"><span style="color:#F97583">        var</span><span style="color:#E1E4E8"> app </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Vue</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">            el:</span><span style="color:#9ECBFF">'#app'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">            data: {</span></span>
<span class="line"><span style="color:#E1E4E8">                message: </span><span style="color:#9ECBFF">'origin'</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">                code: </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">            },</span></span>
<span class="line"><span style="color:#E1E4E8">            watch:{</span></span>
<span class="line"><span style="color:#B392F0">                message</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">newVal</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">oldVal</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">                    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(newVal, oldVal)</span></span>
<span class="line"><span style="color:#E1E4E8">                },</span></span>
<span class="line"><span style="color:#B392F0">                code</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">value</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">                    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'t:'</span><span style="color:#E1E4E8">, value)</span></span>
<span class="line"><span style="color:#E1E4E8">                }</span></span>
<span class="line"><span style="color:#E1E4E8">            },</span></span>
<span class="line"><span style="color:#E1E4E8">            methods:{</span></span>
<span class="line"><span style="color:#B392F0">                onClick</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">                    this</span><span style="color:#E1E4E8">.message </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> 'changed'</span></span>
<span class="line"><span style="color:#79B8FF">                    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">$nextTick</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.$refs.code))</span></span>
<span class="line"><span style="color:#79B8FF">                    this</span><span style="color:#E1E4E8">.code </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#9ECBFF">'</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic">                }</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        })</span></span>
<span class="line"><span style="color:#F97583">    &#x3C;/</span><span style="color:#E1E4E8">script</span><span style="color:#F97583">></span></span>
<span class="line"><span style="color:#F97583">&#x3C;/</span><span style="color:#E1E4E8">body</span><span style="color:#F97583">></span></span></code></pre>
<p>点击按钮时（注意queue = []、callBack = []是全局变量）</p>
<ol>
<li>执行到<code>this.message = 'changed'</code></li>
</ol>
<p><code>queue</code>会<code>push</code>两个watcher，一个是<code>message</code>对应的<code>user watcher</code>，一个是<code>render wacther</code>，<code>callBack</code>有一个包含执行<code>queue</code>的函数</p>
<ol start="2">
<li>执行到<code>this.$nextTick(() => console.log(this.$refs.code))</code></li>
</ol>
<p><code>queue</code>还是两个<code>watcher</code>，<code>callBack</code>会<code>push</code>一个函数也就是<code>() => console.log(this.$refs.code)</code></p>
<ol start="3">
<li>执行到<code>this.code = 2</code></li>
</ol>
<p><code>queue</code>增加一个<code>code</code>对应的<code>user watcher</code>，想再次加入<code>render watcher</code>时，发现里面已经有一个<code>render watcher</code>就不会重复添加（根据<code>watcher.id</code>来判断）</p>
<ol start="4">
<li>这时同步代码都执行完，现在开始执行<code>flushCallbacks()</code>，里面依次执行<code>callBack</code>函数，<code>callBack[0]</code>包含执行queue的函数，执行<code>queue</code>里面的所有的<code>watcher.run</code>，这个时候页面节点就已经发生改变了，由于<code>this.code</code>对应的<code>watcher</code>也在当前<code>queue</code>里面，所以执行<code>callBack[1]</code>时，就可以取到最新的节点内容。</li>
</ol>
<h3 id="flushschedulerqueue">flushSchedulerQueue</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> flushSchedulerQueue</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">  currentFlushTimestamp </span><span style="color:#F97583">=</span><span style="color:#B392F0"> getNow</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">  flushing </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> watcher, id</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // 排序watcher队列</span></span>
<span class="line"><span style="color:#6A737D">      // 1. 组件更新是从父到子的过程，因为组件创建过程也是从父到子的</span></span>
<span class="line"><span style="color:#6A737D">      // 2. 为了让user watcher比render watcher更早执行</span></span>
<span class="line"><span style="color:#6A737D">      // 3. 当一个组件在父组件的watcher中销毁时，这个组件的watcher应该被跳过。</span></span>
<span class="line"><span style="color:#E1E4E8">  queue.</span><span style="color:#B392F0">sort</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">a</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">b</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> a.id </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> b.id)</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (index </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; index </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> queue.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; index</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    watcher </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> queue[index]</span></span>
<span class="line"><span style="color:#6A737D">    // 更新页面节点数据前调用beforeUpdate钩子函数</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (watcher.before) {</span></span>
<span class="line"><span style="color:#E1E4E8">      watcher.</span><span style="color:#B392F0">before</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> watcher.id</span></span>
<span class="line"><span style="color:#E1E4E8">    has[id] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span></span>
<span class="line"><span style="color:#6A737D">    // 更新页面节点</span></span>
<span class="line"><span style="color:#E1E4E8">    watcher.</span><span style="color:#B392F0">run</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#6A737D">    // in dev build, check and stop circular updates.</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (process.env.</span><span style="color:#79B8FF">NODE_ENV</span><span style="color:#F97583"> !==</span><span style="color:#9ECBFF"> 'production'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8"> has[id] </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      circular[id] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (circular[id] </span><span style="color:#F97583">||</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (circular[id] </span><span style="color:#F97583">></span><span style="color:#79B8FF"> MAX_UPDATE_COUNT</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">        warn</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">          'You may have an infinite update loop '</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#E1E4E8">            watcher.user</span></span>
<span class="line"><span style="color:#F97583">              ?</span><span style="color:#9ECBFF"> `in watcher with expression "${</span><span style="color:#E1E4E8">watcher</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">expression</span><span style="color:#9ECBFF">}"`</span></span>
<span class="line"><span style="color:#F97583">              :</span><span style="color:#9ECBFF"> `in a component render function.`</span></span>
<span class="line"><span style="color:#E1E4E8">          ),</span></span>
<span class="line"><span style="color:#E1E4E8">          watcher.vm</span></span>
<span class="line"><span style="color:#E1E4E8">        )</span></span>
<span class="line"><span style="color:#F97583">        break</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // keep copies of post queues before resetting state</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> activatedQueue</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> activatedChildren.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> updatedQueue</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> queue.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">  resetSchedulerState</span><span style="color:#E1E4E8">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // call component updated and activated hooks</span></span>
<span class="line"><span style="color:#B392F0">  callActivatedHooks</span><span style="color:#E1E4E8">(activatedQueue)</span></span>
<span class="line"><span style="color:#B392F0">  callUpdatedHooks</span><span style="color:#E1E4E8">(updatedQueue)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  // devtool hook</span></span>
<span class="line"><span style="color:#6A737D">  /* istanbul ignore if */</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (devtools </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> config.devtools) {</span></span>
<span class="line"><span style="color:#E1E4E8">    devtools.</span><span style="color:#B392F0">emit</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'flush'</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="如何建立联系">如何建立联系</h3>
<div class="custom-container tip"><p class="custom-container-title">代码例子</p><pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#B392F0">  computed</span><span style="color:#E1E4E8">: {</span></span>
<span class="line"><span style="color:#B392F0">      firstComputed</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">          if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.toggle) {</span></span>
<span class="line"><span style="color:#F97583">              return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.message </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.num </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 33</span></span>
<span class="line"><span style="color:#E1E4E8">          }</span></span>
<span class="line"><span style="color:#F97583">          return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.message </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.anotherNum </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 33</span></span>
<span class="line"><span style="color:#E1E4E8">      }，</span></span>
<span class="line"><span style="color:#B392F0">      secondComputed</span><span style="color:#E1E4E8">(){</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.message</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre><p>我们知道在data中的每个属性都会实例化一个Dep类，假设下面试实例化出来的Dep类:<br>
<code>message => dep.id = 3</code><br>
<code>num => dep.id = 4</code><br>
<code>anotherNum => dep.id = 5</code><br>
<code>toggle => dep.id = 6</code><br>
计算属性<code>firstComputed</code>对应的<code>watcher.id = 1</code><br>
计算属性<code>secondComputed</code>对应的<code>watcher.id = 2</code><br></p></div>
<p>首先要明白一点，watcher和dep是多对多的关系，可以这样理解：在计算属性中可以有多个数据，比如:</p>
<ul>
<li>当<code>toggle=true</code>时<code>firstComputed</code>的watcher对应多个<code>depIds:[6,3,4]</code></li>
<li><code>message</code>的dep中订阅了多个<code>watcherIds:[1, 2]</code></li>
</ul>
<p><strong>现在来看看<code>depIds:[6,3,4]</code>是怎么放入的？</strong></p>
<ol>
<li>执行到firstComputed时，会先判断dirty是否为<code>true</code>,然后会走<code>watcher.get => pushTarget => this.getter.call(vm,vm)</code>也就是从<code>if (this.toggle)</code>开始走下去</li>
<li>从而进入到toggle的getter函数，触发了<code>dep.depend => Dep.target.addDep(this)</code>，这时候开始建立关系，newDepIds先判断已经含有<code>newDepIds.add(6)</code>，<code>newDeps.push(dep:{id:6})</code>，<code>dep.addSub(watcher:{id:1})</code>，这边为了更好的看清怎么添加关系的，所以我在实例后面加了个id作为识别，真正情况下只是添加这个实例。执行完这一步后，结果如下：</li>
</ol>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#79B8FF">  Watcher</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">addDep</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> addDep</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">dep</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> dep.id;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(id)) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.newDepIds.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(id);</span></span>
<span class="line"><span style="color:#6A737D">      // watcher中放入dep</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.newDeps.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(dep);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.depIds.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(id)) {</span></span>
<span class="line"><span style="color:#6A737D">        // dep中放入watcher</span></span>
<span class="line"><span style="color:#E1E4E8">        dep.</span><span style="color:#B392F0">addSub</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span></code></pre>
<div class="custom-container tip"><p class="custom-container-title">watcher:{id}</p><p>newDepIds: [6]<br>
newDeps: [dep:{id</p><div></div>}]<br>
deps:[]<br>
depIds:[]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<ol start="3">
<li>从<code>if (this.toggle)</code>执行完到<code>return</code>后结果就会变成:</li>
</ol>
<div class="custom-container tip"><p class="custom-container-title">watcher:{id}</p><p>newDepIds: [6,3,4]<br>
newDeps: [dep:{id</p><div></div>},dep:{id<div></div>},dep:{id<div></div>}]<br>
deps:[]<br>
depIds:[]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<ol start="4">
<li>执行完<code>this.getter.call(vm,vm)</code>后就又回到<code>watch.get</code>，执行<a style="color:rgb(122, 214, 253);" href="#cleanupdeps">watcher.cleanupDeps</a>，由于这是第一次执行这个步骤。所以没有旧的deps，只是简单的转移数据和置空数据，结果如下所示:</li>
</ol>
<div class="custom-container tip"><p class="custom-container-title">watcher:{id}</p><p>newDepIds: []<br>
newDeps: []<br>
deps:[dep:{id</p><div></div>},dep:{id<div></div>},dep:{id<div></div>}]<br>
depIds:[6,3,4]<br><p></p></div>
<ol start="5">
<li>当我们将toggle改为false时：又从<code>firstComputed</code>执行到<code>if (this.toggle)</code>了，又进来toggle的getter函数，触发了<code>dep.depend => Dep.target.addDep(this)</code>，开始建立关系，这一次if条件变了，return变成第二个了，所以执行完所有的getter，最终的结果如下所示：</li>
</ol>
<div class="custom-container tip"><p class="custom-container-title">watcher:{id}</p><p>newDepIds: [6,3,5]<br>
newDeps: [dep:{id</p><div></div>},dep:{id<div></div>},dep:{id<div></div>}]<br>
deps:[6,3,4]<br>
depIds:[dep:{id<div></div>},dep:{id<div></div>},dep:{id<div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br>
这个<code>dep</code>已经不需要订阅<code>watcher:{id:1}</code>了，需要在cleanupDeps里面移除<p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<ol start="6">
<li>走完后开始走<code>watcher.cleanupDeps</code>,这次旧的<code>deps</code>是有数据的，看到<code>dep:{id:4}</code>还在订阅这个<code>computed watcher</code>，所以<code>cleanupDeps</code>需要移除这个订阅，并且将最新的数据转移到<code>deps</code>，<code>depIds</code>，最终的结果如下所示：</li>
</ol>
<div class="custom-container tip"><p class="custom-container-title">watcher:{id}</p><p>newDepIds: []<br>
newDeps: []<br>
deps:[6,3,5]<br>
depIds:[dep:{id</p><div></div>},dep:{id<div></div>},dep:{id<div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[]<br>
这个<code>dep</code>已经不订阅<code>watcher:{id:1}</code>了</p></div>
<div class="custom-container tip"><p class="custom-container-title">dep:{id}</p><p>dep.subs[watcher:{id</p><div></div>}]<br><p></p></div>
<p>上面的过程用一个流程图表示：</p>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="842" height="1129" src="/_astro/Vue2-addDep-cleanupDeps.BoDzzuR8_2pUPe3.webp" ></p>
<h4 id="总结depwatcher">总结dep&#x26;&#x26;watcher</h4>
<p>为了在每次更新时都保持dep与watcher都有相同的依赖和订阅，所以dep和watcher都有相互的变量可以访问到对方，做到你中有我，我中有你的状态。</p>
<h2 id="set">$set</h2>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583"> function</span><span style="color:#B392F0"> set</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">target</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">key</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">val</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">  //  如果target是null、undefined、基础类型就报错。计算属性是</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isUndef</span><span style="color:#E1E4E8">(target) </span><span style="color:#F97583">||</span><span style="color:#B392F0"> isPrimitive</span><span style="color:#E1E4E8">(target)</span></span>
<span class="line"><span style="color:#E1E4E8">    ) {</span></span>
<span class="line"><span style="color:#B392F0">      warn</span><span style="color:#E1E4E8">((</span><span style="color:#9ECBFF">"Cannot set reactive property on undefined, null, or primitive value: "</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> ((target))));</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    //</span></span>
<span class="line"><span style="color:#6A737D">    // 如果目标是数组的话就用splice来插入，因为Vue本身有劫持数组的方法，其中包括splice，这样就会触发数据响应</span></span>
<span class="line"><span style="color:#6A737D">    // 这里假设的情况是target是data里面的数组</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (Array.</span><span style="color:#B392F0">isArray</span><span style="color:#E1E4E8">(target) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#B392F0"> isValidArrayIndex</span><span style="color:#E1E4E8">(key)) {</span></span>
<span class="line"><span style="color:#E1E4E8">      target.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">max</span><span style="color:#E1E4E8">(target.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">, key);</span></span>
<span class="line"><span style="color:#E1E4E8">      target.</span><span style="color:#B392F0">splice</span><span style="color:#E1E4E8">(key, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, val);</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> val</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 如果key是在target的属性里面的属性，直接在该属性上面改动，然后触发defineReactive$$1的setter</span></span>
<span class="line"><span style="color:#6A737D">    // 这里假设的情况是target是data里面的对象</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (key </span><span style="color:#F97583">in</span><span style="color:#E1E4E8"> target </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">(key </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> Object</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#E1E4E8">      target[key] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> val</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 如果target._isVue是true就说明vue实例，不能添加属性</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> ob </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (target).__ob__;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (target._isVue </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> (ob </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> ob.vmCount)) {</span></span>
<span class="line"><span style="color:#B392F0">      warn</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#9ECBFF">        'Avoid adding reactive properties to a Vue instance or its root $data '</span><span style="color:#F97583"> +</span></span>
<span class="line"><span style="color:#9ECBFF">        'at runtime - declare it upfront in the data option.'</span></span>
<span class="line"><span style="color:#E1E4E8">      );</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> val</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 计算属性是没有__ob__的，所以计算属性是不会直接进来这个分支，然后在内存里面值是变了，但是页面没有更新的。</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ob) {</span></span>
<span class="line"><span style="color:#E1E4E8">      target[key] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> val;</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> val</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    //如果都没有命中上面的条件，那么就是认为是用户想定义新的响应式数据</span></span>
<span class="line"><span style="color:#B392F0">    defineReactive$$1</span><span style="color:#E1E4E8">(ob.value, key, val);</span></span>
<span class="line"><span style="color:#E1E4E8">    ob.dep.</span><span style="color:#B392F0">notify</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> val</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h2 id="nexttick">nexttick</h2>
<h3 id="全局变量">全局变量</h3>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> isUsingMicroTask </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> callbacks </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> []; </span><span style="color:#6A737D">// 用来存储回调函数的数组</span></span>
<span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> pending </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span></code></pre>
<h3 id="flushcallbacks">flushCallBacks</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>调用全局变量<code>callbacks</code>中的所有函数</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> flushCallbacks</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#E1E4E8">    pending </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> copies </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> callbacks.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 拷贝数组</span></span>
<span class="line"><span style="color:#E1E4E8">    callbacks.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;  </span><span style="color:#6A737D">// 清空数组</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">var</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> copies.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // 运行数组里的所有函数</span></span>
<span class="line"><span style="color:#E1E4E8">      copies[i]();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="timerfunc">timerFunc</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>只需要记得timerFunc是一个微任务，，如果不懂微任务的话可以看着这一篇文章:<a href="./interview.md#event-loop">微任务和宏任务</a>，下面代码是为了兼容多个浏览器和UIWebview，在正常谷歌浏览器时可把代码省略成下面这样，timerFunc的函数作用是将<code>flushCallbacks</code>函数推入微任务队列</p><pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> p </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    timerFunc</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">      p.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(flushCallbacks);</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span></code></pre></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  var</span><span style="color:#E1E4E8"> timerFunc;</span></span>
<span class="line"><span style="color:#6A737D">  // Promise is available, we will use it:</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#79B8FF"> Promise</span><span style="color:#F97583"> !==</span><span style="color:#9ECBFF"> 'undefined'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#B392F0"> isNative</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> p </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    timerFunc</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">      p.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(flushCallbacks);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (isIOS) { </span><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(noop); }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">    isUsingMicroTask </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">isIE </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> typeof</span><span style="color:#E1E4E8"> MutationObserver </span><span style="color:#F97583">!==</span><span style="color:#9ECBFF"> 'undefined'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#E1E4E8"> (</span></span>
<span class="line"><span style="color:#B392F0">    isNative</span><span style="color:#E1E4E8">(MutationObserver) </span><span style="color:#F97583">||</span></span>
<span class="line"><span style="color:#6A737D">    // PhantomJS and iOS 7.x</span></span>
<span class="line"><span style="color:#E1E4E8">    MutationObserver.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> '[object MutationObserverConstructor]'</span></span>
<span class="line"><span style="color:#E1E4E8">  )) {</span></span>
<span class="line"><span style="color:#6A737D">    // Use MutationObserver where native Promise is not available,</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> counter </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> observer </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> MutationObserver</span><span style="color:#E1E4E8">(flushCallbacks);</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> textNode </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> document.</span><span style="color:#B392F0">createTextNode</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">(counter));</span></span>
<span class="line"><span style="color:#E1E4E8">    observer.</span><span style="color:#B392F0">observe</span><span style="color:#E1E4E8">(textNode, {</span></span>
<span class="line"><span style="color:#E1E4E8">      characterData: </span><span style="color:#79B8FF">true</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#B392F0">    timerFunc</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#E1E4E8">      counter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (counter </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">%</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">      textNode.data </span><span style="color:#F97583">=</span><span style="color:#B392F0"> String</span><span style="color:#E1E4E8">(counter);</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">    isUsingMicroTask </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">typeof</span><span style="color:#E1E4E8"> setImmediate </span><span style="color:#F97583">!==</span><span style="color:#9ECBFF"> 'undefined'</span><span style="color:#F97583"> &#x26;&#x26;</span><span style="color:#B392F0"> isNative</span><span style="color:#E1E4E8">(setImmediate)) {</span></span>
<span class="line"><span style="color:#6A737D">    // Fallback to setImmediate.</span></span>
<span class="line"><span style="color:#6A737D">    // Techinically it leverages the (macro) task queue,</span></span>
<span class="line"><span style="color:#6A737D">    // but it is still a better choice than setTimeout.</span></span>
<span class="line"><span style="color:#B392F0">    timerFunc</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#B392F0">      setImmediate</span><span style="color:#E1E4E8">(flushCallbacks);</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    // Fallback to setTimeout.</span></span>
<span class="line"><span style="color:#B392F0">    timerFunc</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#B392F0">      setTimeout</span><span style="color:#E1E4E8">(flushCallbacks, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<h3 id="nexttick-1">nextTick</h3>
<div class="custom-container tip"><p class="custom-container-title">提示</p><p>调用Vue.$nextTick(cb())，会将cb推入到全局变量callbacks，只有当pending为false时才可以调用timerFunc()，所以callback的length等于0和pending为false只能是同时成立的，因为这段代码是同步的。</p></div>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="js"><code><span class="line"><span style="color:#F97583">  function</span><span style="color:#B392F0"> nextTick</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">cb</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">ctx</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    var</span><span style="color:#E1E4E8"> _resolve;</span></span>
<span class="line"><span style="color:#6A737D">    // 将回到函数cb推入全局变量callbacks</span></span>
<span class="line"><span style="color:#E1E4E8">    callbacks.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (cb) {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">          cb.</span><span style="color:#B392F0">call</span><span style="color:#E1E4E8">(ctx);</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (e) {</span></span>
<span class="line"><span style="color:#B392F0">          handleError</span><span style="color:#E1E4E8">(e, ctx, </span><span style="color:#9ECBFF">'nextTick'</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (_resolve) {</span></span>
<span class="line"><span style="color:#B392F0">        _resolve</span><span style="color:#E1E4E8">(ctx);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#6A737D">    // 判断当前微任务是否正在执行，pending会在flushCallbacks函数执行时复制成false</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">pending) {</span></span>
<span class="line"><span style="color:#E1E4E8">      pending </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">      timerFunc</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    // 如果没有传入cb时，返回Promise 调用方式:Vue.$nextTick().then(resolve => {})</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">cb </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#F97583"> typeof</span><span style="color:#79B8FF"> Promise</span><span style="color:#F97583"> !==</span><span style="color:#9ECBFF"> 'undefined'</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#F97583"> new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        _resolve </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> resolve;</span></span>
<span class="line"><span style="color:#E1E4E8">      })</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span></code></pre>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1700" height="832" src="/_astro/Vue2-nexttick-arrayDemo1.C06merja_Z2vnaue.webp" ></p>
<p>看上图，点击按钮后页面是不会重新渲染的，这很正常，因为前面讲过，Vue只提供那些变异方法才能促使页面更新，vm.$Set也是这样的，但是看下面一张图</p>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1692" height="806" src="/_astro/Vue2-nexttick-arrayDemo2.D83ww-oN_Z589sC.webp" >
点击测试，页面数据变换了，为什么？可以看出代码多加了一行<code>this.message = 'hello'</code>，当执行到这一句时会调用<code>dep.notify</code>，触发<code>render watcher</code>，但是没有马上执行只是放在nexttick队列中，等待宏任务执行完在执行nexttick宏任务，再执行到<code>this.realArr[0] = '111'</code>，没有触发<code>dep.notify</code>，但是对应的引用地址中的值确实变了，所以在后面执行render watcher时，再次调用this.realArr的时候值就变了。</p>
<h2 id="原理图">原理图</h2>
<p><img  loading="lazy" decoding="async" fetchpriority="auto" width="1898" height="1278" src="/_astro/Vue2-theory.CctrSV8s_RwS.webp" ></p>
<p>解读：
在实例化<code>data</code>对象时，递归遍历，将每个数据都对应的实例化一个<code>Dep</code>类，并且在<code>defineReactive</code>的get函数中设置<code>dep.depend</code>,在<code>set</code>函数设置<code>dep.notify</code>，在页面渲染、<code>computed</code>或<code>watch</code>的时候会触发<code>get</code>然后就会设置依赖，在数据更新时就通过<code>set</code>中的<code>dep.notify</code>来通知在<code>get</code>中设置的依赖，达到响应式更新数据的效果，更新数据或页面这一操作是放到全局变量<code>callback</code>栈中，当宏任务结束后就以微任务的形式挨个执行<code>callback</code>的更新回调。所以数据是部分更新的，并不是单个更新的。</p>
<h2 id="问题解答">问题解答</h2>
<div class="custom-container tip"><p class="custom-container-title">message为data中定义的对象，vm._data.message和vm.message有什么区别？</p><p>本质上vm._data和vm.data是没有区别的，在<code>initData</code>中<code>vm._data = typeof data === 'function'? getData(data, vm) : data || {};</code>，因为设置<code>defineProperty</code>中的<code>getter</code>、<code>setter</code>需要临时变量来保存用户设置的值，所以新建了<code>_data</code>。</p></div>
<div class="custom-container tip"><p class="custom-container-title">为什么Vue中不能通过索引来修改数组以更新视图？为什么有时候莫名其妙就可以触发视图更新？</p><p>从根源上来讲，Vue2.6通过更改数组索引的方式来更改数组的数据是不会触发<code>defineProperty</code>的<code>set</code>函数，也就不会触发页面更新，但是数组的引用地址对应的数据确实被改了，当你也一起修改某个响应式数据，对应更新的<code>watcher</code>的推到<code>nexttick</code>队列，当宏任务结束后，就会执行nexttick中的队列，页面重新渲染时获取的是数组的最新的数据，有时响应式数据更新在数据修改的后面就会导致页面数组重新获取数据。</p></div>
<div class="custom-container tip"><p class="custom-container-title">为什么只能通过官网指定的几个方法(push、splice…)才能出发数组数据更新？</p><p>在源码<code>arrayMethods</code>可以看出来，Vue2.6是先截取了原生的Array.prototype的方法，然后重写方法获取用户传入的参数，在重写方法内部先是调用原方法，然后调用<code>ob.dep.notify()</code>来更新对应<code>watcher</code>。</p></div>
<div class="custom-container tip"><p class="custom-container-title">为什么通过this.$set就可以触发数组下标更新导致更新视图？</p><p>在这一篇<a href="./DefineProperty&#x26;&#x26;Proxy.md">DefineProperty和Proxy</a>中讲过它们两个的区别，因为Vue2.6中用的是<code>DefineProperty</code>，而这个方法必须要传入目标对象<code>obj</code>,目标对象的键<code>Key</code>，这就造成了很难动态的添加属性，为什么说很难呢？因为这个是可以实现的，比如本来data里面有数据message，message是执行过<code>defineReactive</code>的，所以可以监听到getter、setter，但是你想新建一个flag，直接<code>data.flag = 10</code>，每次调用前都需要判断是否定义过，没有定义的就执行<code>defineReactive</code>，无疑是很费性能的，数据也是一样，数组是没有key的，所以更是监听不了的，Vue.$Set也是通过判断是否是数组，是的话再调用那些变异方法来执行更新。</p></div>
<div class="custom-container tip"><p class="custom-container-title">computed和watch的区别有哪些，computed的缓存是怎么做到的？</p><p>watch和computed一个重要区别就是，监听的属性发生改变时就执行watch函数，计算属性和data里面属性一样，只有在某个地方用到时才会调用计算属性的getter，而getter中包含表达式。然后计算属性是可以缓存的，这个缓存指的是基于它们的响应式依赖进行缓存的，<code>defin·Reactive</code>中set中<code>oldValue</code>和<code>newValue</code>如果不等时就会触发<code>dep.notify=>dep.update=>this.dirty=true</code>，在获取计算属性的时候，判断dirty会true时就会调用<code>this.get</code>重新获取对应的值。</p></div>
<div class="custom-container tip"><p class="custom-container-title">社区经常提到的watcher和dep到底为响应式数据提供了怎么样的逻辑</p><p>Vue2.6中只会在computed、watch、页面渲染时实例化Watcher，具体看dep与watcher是如何建立联系的可以看<a style="color:rgb(122, 214, 253);" href="#如何建立联系">dep与watcher是如何建立联系</a></p></div> </div> <section class="giscus mx-auto mt-10 w-full"> <div id="giscus-loading" class="text-skin-neutral-5 text-center py-4">
Loading comments...
</div> </section> <script type="module">const i=()=>{const r=document.querySelector(".giscus");if(!r){const e=document.querySelector('script[src="https://giscus.app/client.js"]');e&&e.remove();return}const n=()=>{const e=document.getElementById("giscus-loading");e&&e.remove();const s=document.querySelector('script[src="https://giscus.app/client.js"]');s&&s.remove();const t=document.createElement("script");t.src="https://giscus.app/client.js",t.setAttribute("data-repo","cjinhuo/cjinhuo.github.io"),t.setAttribute("data-repo-id","MDEwOlJlcG9zaXRvcnk2OTk2NDgwNw=="),t.setAttribute("data-category","General"),t.setAttribute("data-category-id","DIC_kwDOBCuUB84Cx9F9"),t.setAttribute("data-mapping","title"),t.setAttribute("data-strict","0"),t.setAttribute("data-reactions-enabled","1"),t.setAttribute("data-emit-metadata","0"),t.setAttribute("data-input-position","top"),t.setAttribute("data-theme","preferred_color_scheme"),t.setAttribute("data-lang","zh-CN"),t.setAttribute("data-loading","lazy"),t.crossOrigin="anonymous",t.async=!0,document.body.appendChild(t)};if("IntersectionObserver"in window){const e=new IntersectionObserver(s=>{s.forEach(t=>{t.isIntersecting&&(n(),e.disconnect())})},{rootMargin:"200px"});e.observe(r)}else n()};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",i):i();document.addEventListener("astro:page-load",i);document.addEventListener("astro:after-swap",i);</script> </article> </main> <footer class="border-t border-skin-card-border"> <div class="max-w-5xl mx-auto px-6 md:px-12 py-8 flex justify-between items-center"> <span class="text-skin-neutral-6 font-mono text-xs">
Shanks &copy; 2026 All rights reserved.
</span> <div class="flex items-center gap-4"> <a href="https://github.com/cjinhuo" target="_blank" class="text-skin-neutral-6 hover:text-skin-neutral-4 transition-colors"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path> <path d="M9 18c-4.51 2-5-2-7-2"></path> </svg> </a> <a href="https://twitter.com" target="_blank" class="text-skin-neutral-6 hover:text-skin-neutral-4 transition-colors"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path> </svg> </a> <a href="mailto:cjinhuo@qq.com" class="text-skin-neutral-6 hover:text-skin-neutral-4 transition-colors"> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"> <rect width="20" height="16" x="2" y="4" rx="2"></rect> <path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path> </svg> </a> </div> </div> </footer> </body></html>